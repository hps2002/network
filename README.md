# 计算机网络囫囵吞枣

## TCP/IP网络模型
### 应用层
常用协议：http、ftp、Telnet、DNS、SMTP等

数据单位为报文。发送方使用http等应用层协议将数据和信息封装成为报文传输到传输层。
应用层在用户态中进行工作，传输层、网络层、网络接口层在内核态；

### 传输层
传输层使用的协议是TCP协议和UDP协议

tcp和udp的区别：
* tcp面向可靠传输，udp面向不可靠传输
* tcp相对于udp拥有流量控制、超时重传、拥塞控制等
* udp相对于tcp的效率高很多，但是udp只负责发送数据包不保证数据包是否到达接收方手上

当数据传输超过MSS（TCP传输的最大报文长度）需要将数据包进行分块，每个分块称为TCP段。
分块的优势在于，某个分块在传输的时候丢失我们只需要重新转发那个分块，不需要重发所有的数据包。

接收数据包的时候，tcp协议通过设备端口进行应用的区分，每个进程都拥有不同的端口，使得tcp协议能准确的将数据包传输给应用。udp也是通过端口号进行传输。

### 网络层

网络层的作用是将传输层封装好的数据段，从一台设备传输到另一台设备。

网络层使用的协议是ip协议：
将传输层封装好的报文作为数据部分，在前面添加ip头部形成ip报文，如果ip报文超过MTU（以太网中大小为1500字节），就会再次分片；

ip协议：
ip头部 + (tcp头部 + (应用层报文))

网络层进行传递的时候通过设备的ip地址进行传输
ip地址一般采用的是ipv4协议或者ipv6协议。

ipv4协议中：主要由32位的二进制数组成。由网络号和主机号组成：网络号负责表示当前的ip地址属于哪个子网、主机号表示当前设备属于子网下的哪台主机。

通过子网掩码求出网络号和主机号；

ip协议在传输的过程中主要通过路由协议进行路径的选取。在ip协议中：IP地址告诉当前数据包要往哪个方向走，路由协议则告诉当前数据包要走哪一条路。

### 网络接口层
网络接口层将网络层封装下来的数据再次进行包装，即在ip协议报文前面加上一个MAC地址<br>
MAC地址是每台主机的标识，以太网判断网络数据包的目的地和ip地址的方式不同，所以要通过MAC头部进行以太网之间的通讯。

网络数据包在底层设备间进行传输的过程：
网络数据包通过网卡中的驱动程序将数据转化成电平信号，通过网线在以太网上进行传播

首先到达交换机，交换机先通过校验MAC地址检查是否为自己接收的数据包，如果不是的话就丢弃；如果是的话就接收，接收之后将MAC头部解析，重新封装MAC头部，通过目的ip地址查找应该交付哪个端口转发，如果交换机的缓存中找不到对应端口转发，那么将进行广播， 如果找到端口则重新封装MAC头部，其中的目的MAC地址通过ARP协议获取。

然后到达路由器，路由器也是先校验MAC地址，查看是否为自己接收的数据包，如果是的话就将数据包进行解析，根据目的IP地址要从哪个端口转发，如果在路由表中找不到的话从网关进行转发，在这里的话也是需要重新封装MAC头部的，源目的地址也是通过ARP协议获取。如果在一个路由器的下一跳网关为空的话说明网络数据包的目的地已经到了。

然后传输到另外一台客户端中通过网卡接收数据
在整个过程中，数据包的的源IP地址和目的IP地址没有改变，改变的只有底层的MAC头部，帧起始标识符，帧结束标识符，数据校验码。

## 输入网址之后做了什么？

### url解析
在浏览器输入一个网址之后首先浏览器要对这个网址进行解析，得到其中隐含的信息，包括：访问数据的协议、服务器域名、请求文件路径；

例如：http://www.huangpeishen.com/index/page1/home.html
其中：
* http &emsp; 表示访问数据的协议
* www.huangpeishen.com &emsp;表示访问的服务器
* /index/page/home.html &emsp;表示请求文件的路径

**如果没有后面的请求文件路径**就会返回服务器的默认页面，一般是服务器的首页

### 生成请求报文
如果是http协议的话会生成http请求信息向服务器请求数据<br>
http协议有两种请求报文:**Get报文**和**Post报文**

请求报文由**请求行** + **消息头** + **消息体组成**
* 请求行：方法 + sp + URL + sp + 版本 + cr + lf
* 消息头：首部字段名 + sp + 字段值 + cr + lf
····
首部字段名 + sp + 字段值 + cr + lf
* cr + lf
* 消息体：数据

响应报文由**状态行** + **消息头** + **消息体**
* 状态行：版本 + 状态码 + 短语
* 消息头：首部字段名 + 字段值
首部字段名 + 字段值
* 消息体：数据

### 域名解析
生成http请求消息之后，将http报文委托操作系统转发给服务器

通过DNS服务器查询获取服务器的IP地址

* 域名解析：
域名中使用**句点**进行分离域名，越靠右的域名层级越高
在实际域名中还有一个`.`，比如`www.huangpeishen.com.`其中的`.`就是根域，下一层就是.com, 在下一层就是.huangpeishen

```
DNS服务器查询服务器域名对应的IP地址流程：
1.首先向本地的域名服务器的缓存中查找是否存在当前域名的ip地址
2.如果本地服务器中不存在当前域名的ip地址，本地DNS服务器就要去根域名服务器请求当前域名的ip地址
3.根域名服务器不会直接给出具体的ip地址，它会给出下一层域名的DNS服务器ip地址，让你去下一层DNS服务器中寻找
4.当你再次进入下一层服务器的时候，它也不会直接给出具体的ip地址，它也是给出下一层DNS服务器的地址，让你再下一层的寻找
5.如此循环，一直来到权威DNS服务器的时候，才能获得当前请求的IP地址。权威DNS服务器就是网址中的".huangpeishen"，因为这才是IP地址的出处。权威DNS服务器将IP地址返回给本地DNS服务器，本地DNS服务器再返回给客户端
```

### 交付协议栈
获取到IP地址之后将http传输工作交付操作系统中的协议栈，通过tcp协议进行传输
tcp协议封装好http报文之后交付ip协议封装

通过tcp传输数据之前要建立tcp连接 -> 三次握手
建立好连接之后才能通过tcp协议对应用层的报文进行数据传输

tcp封装好的报文来到要再网络上传输要通过ip协议进行传输，即再tcp数据报的前面加上一个ip头部，IP头部里面有源IP地址、目的IP地址。
IP协议有IPv4、ipv6协议

### 两点之间传输

ip协议封装好的数据报要在设备之间传输需要在前面加上一个mac头部，用于两点之间的网络包传递
发送方的mac地址直接使用读取网卡中的mac地址即可
接收方的mac地址要使用arp协议进行ip广播，获得对应ip地址的MAC地址；
如果IP数据报超出MTU的话要进行切分。

最后数据包通过网卡中的驱动程序转化成电信号，在开头加上报头和起始帧分节符，后面加上检验序列。

### 数据包传输
数据从客户端出来之后首先到达交换机，在交换机中查询MAC地址表转发到路由器上，在路由器上根据路由转发协议，一步一步的转发，使得网络包到达终点。

传输的传输的过程中网络包中变化的只有MAC头部，源ip和目标ip是始终不变的。

### 获取服务器资源（服务器应答报文传递）
最终服务器接收客户端传来的数据包

通过一层一层的解析，确认MAC地址，确认ip地址、确认tcp序列号和端口，将数据包转发给正在监听这个端口的http进程。

通过客户端的http报文请求，返回对应的资源文件。如果客户端访问一个页面，服务器将这个页面封装在http的响应报文中，响应报文经过tcp封装，IP封装，MAC封装，最后经过和请求报文一样的传输过程，到达客户端解析并渲染在客户端主机上。

****************************************************************************************************
总结：在浏览器中输入网址之后，首先要进行的是
* url解析，通过url解析知道用的是什么协议，哪个服务器，请求什么资源文件
* 封装请求报文，向服务器发送请求
* 查找DNS服务器，获取服务器的ip地址，客户端首先向本地DNS服务器询问是否缓存当前网址的ip地址，如果没有则依次从根域名服务器到权威服务器进行查找，返回ip地址；
* 封装tcp报文，添加上源端口和目的端口以及tcp报文的序列号。在发送网络数据包之前首先要建立tcp连接(三次握手)
* 封装ip报文
* 封装MAC头部，通过arp进行获取目的MAC的报文
* 在网络设备上进行传输，
* 服务端接收http请求，封装客户端请求资源生成响应报文回传客户端。


## http
### http是什么？
http是超文本传输协议；
超文本：包括文字、图片视频等都可以被看作是超文本。超文本还具有超链接跳转的功能，从一个超文本跳转到另外一个超文本。
传输：http协议是计算机世界中两点之间传输的约定规范。逻辑上是两点，实际上可以存在中间转接。
协议：http是一个双向协议客户端向服务端发起请求，服务端对客户端经进行应答。针对于客户端和服务端两点之间的协议

综上，http协议是计算机世界里**两点**之间**传输**超文本数据的约定规范。其中两点之间的不仅仅是服务器和客户端之间，还可以在服务端和服务端之间。

### http五大常见状态码
1xx, 提示信息，表示协议正在处理的中间阶段，还需要后续的操作；

2xx，成功，报文被收到并正确处理
* '200 OK'，最常见的状态码，表示成功，如果是非```HEAD```请求都有body数据
* '204 not content'，成功，不包含数据
* '206 Partial Content'，是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态

3xx, url重定向，表示资源地址发生了变化，需要客户端用新的url请求资源
* '301 Moved Permanently'，永久重定向，表示请求资源已经不存在了，需要用新的地址访问
* '302 Found'，表示临时重定向，表示资源还在，但是用新的url访问
    在301和302的状态中都会在响应头中使用字段Location，指明后续访问的url，浏览器回自己访问新的url；
* '304 Not Modified'，表示访问资源没有被修改，重定向到缓存，用于缓存控制。

4xx，表示客户端报文有误，服务器无法处理
* '400 Bad Request'，表示客户端请求的报文有错误，但是个笼统的错误
* '403 Forbidden'，表示资源禁止访问，并不是客户端的请求出错
* '404 Not Found'，表示请求的资源在服务器上找不到，所以无法提供给客户端

5xx，表示客户端提供了正确的报文，只是在服务端运行中出错了，属于服务端错误码
* '500 Internal Server Error'，服务器发生错误，但是发生什么错误不知道
* '501 Not Implemented'，表示客户端请求的功能还不支持
* '502 Bad GateWay'，通常是服务器或者网关代理时出现的代码，表示服务器自身工作正常，访问服务器后端出现了问题
* '503 Service Unavailable'，表示服务器正忙，暂时无法响应客户端

### http常见字段
"Host", 指定服务器域名，使用"Host"字段可以将请求同一台服务器的不同网站<br>
"Content-Lenght"，服务器返回数据使用该字段表示返回数据的长度<br>
    http是使用Tcp协议进行传输的，所以肯定回出现粘包问题<br>
    http通过设置回车符、换行符作为HTTP HEAD的边界，设置content-Lenght<br>
    作为body的边界，是为了解决粘包问题<br>
"Connection"，用户客户端要求服务器使用“HTTP 长连接机制”<br>
"Accept"，客户端告诉服务端能接收什么格式的数据<br>
"Content-Type"，服务端返回数据的合适<br>
"Contene-Encoding"，说明数据的压缩方法<br>

### Get和Post
Get请求是从服务器中获取指定资源，可以是静态的文本、视频、图片<br>
Post是根据请求符合对指定资源做出处理，Post携带的数据在报文的Body中，大小不限<br>

Get和Post都是幂等的吗？
**幂等**：指进行多次相同的操作，不会破坏服务器的资源<br>
Get一般用于请求服务器的资源，所以它不会修改服务器的资源，所以Get是幂等的<br>
Post一般携带数据符合要求服务器做出处理，可能会修改服务器的资源，如数据库。所以Post是不幂等的<br>

但是Get也可以进行修改数据的请求，Post也可以用于请求资源，但是这样很反人类，不是吗？<br>
Get也可以带body, 且Post也可以带url

### Http缓存技术
分为强缓存和协商缓存

#### 强缓存
浏览器请求的资源是否过期，如果没有过期就使用缓存中的资源，如果过期就重新向服务器请求资源，重新向服务器请求资源要配合协商缓存进行操作；
在HTTP响应头部中使用Cache-Control和Expires来实现，前者使用的是相对时间，后者使用的是绝对时间，但是建议使用的前者实现强缓存。

#### 协商缓存
当本地缓存过期后，使用协商缓存向服务器询问是否本地缓存中的资源是否过期，如果过期的话服务器重新发送资源，如果没有过期浏览器使用本地缓存的资源

有两种实现协商缓存的方法：
* 第一种：请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现<br>
    通过文件的最后修改日期进行判断
* 第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag<br>
    通过文件的唯一标识符，如果文件的唯一标识符与客户端的不同，说明资源已经被修改，需要重新获取资源。

以上两种方法优先使用第二种，因为有些文件的修改时间是秒级以内的，第一种能检测的时间只能达到秒级，但是使用第二种方法能在一面内刷新多次。

### http/1.1特性
优点：简单、灵活易扩展、应用广泛和跨平台

* 基本的报文格式是：```head + body```，头部就是`关键字` + `值`，比较直观
* http属于应用层，所以下层可以任意扩展：如http和https<br>
    http, http/1.1, http/2.0使用的是tcp传输协议，http/3.0使用的是UDP协议
* 无论是台式机或者手机都兼容http协议

缺点：无状态、明文传输、不安全
* 无状态：无状态有好也有坏，好处是服务器不会记录http的状态，所以不需要额外的资源记录信息，还能减轻服务器的负担。坏处在于，在完成一些关联操作的时候非常麻烦。引入cookies记录客户端的状态。
* 明文传输：在被网络抓包后可以直接被看到传输的内容。
* 不安全：（1）使用明文通信（2）不验证对方身份（3）无法证明报文完整性

### http/1.1性能
http是基于tcp传输协议进行传输的，所以会进行不断地请求应答

#### 长连接机制
长连接机制是http在进行三次握手地时候通过字段"Connection:Keep-Alive"告诉服务器保持长连接，减少不断地三次握手四次挥手的开销。

当长时间没有通信的时候服务器出发定时器断开tcp连接，减少服务器的资源开销。

长连接提出之后就可以进行管道传输：多个请求同时发送。但是管道传输这个技术没有被使用。

* 队头阻塞：请求序列因为某个原因导致客户端一直收不到消息，导致在后面排队的请求一同被堵塞，这就是队头阻塞。


### http 与 https
https是对http报文进行加密的技术手段。

因为明文传输，http存在的风险，https解决风险：
* 窃听风险 -> 混合加密方式解决
* 篡改风险 -> 摘要算法生成独一无二的指纹，用于校验
* 冒充风险 -> 采用数字证书进行验证的方法。


http和https的区别：
* HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
* HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
* 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
* HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

#### TLS握手（四次握手）：
TLS 协议建立的详细流程：

1. ClientHello

首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

2. SeverHello

服务器收到客户端请求后，向客户端发出响应，也就是 ServerHello。服务器回应的内容有如下内容：

（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

3.客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. 服务器的最后回应

服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

### http/1.1优化思路
* 尽量避免发送 HTTP 请求；可以通过强制缓存和协商缓存实现
* 在需要发送 HTTP 请求时，考虑如何减少请求次数；减少重定向次数（代理服务器跳转临时重定向返回请求资源）、（合并请求）合并图片等文件作为一个大文件传输、延迟发送请求（下滑加载）<br>
重定向状态码:301, 302, 303, 307<br>
永久重定向状态码会改变客户端中的url
* 减少服务器的 HTTP 响应的数据大小；无损压缩（gzip）、有损压缩（图片-WebP格式，）

### http/2.0
http/2.0在http/1.1的基础上做出的优化：
* 兼容http/1.1， 没有改变协议，没有改变协议的字段和值，还是基于TCP协议传输
* 压缩头部（采用二进制编码进行压缩），在头部中使用HPACK算法对头部进行压缩。该算法将高频出现的头部和字符串建立了一张静态表写入http/2的框架，值就使用哈夫曼编码进行压缩。对于在静态表中没有出现的字段，采用动态建立的方法进行维护，即：第一次发送全部的字段数据，然后再客户端和服务端中都维护动态表，下次就能通过发送索引号了。当动态表达到上限就关闭http/2释放内存
* 二进制帧，通过帧来传输http报文，可以分为**数据帧**和**控制帧**，每条帧又分为*帧头*和*帧体*，对于帧头用来说明当前帧的长度、类型、标识、流标志（分辨属于哪个stream）
* 并发传输， 提出stream概念，使得多个stream在一条tcp上进行传输。<br>
一个tcp连接包含一个或者多个stream，一个stream包含一个或者多个message， 一个massage包含一个或者多个frame，一个frame可以由多个tcp报文组成。<br>
不同的stream可以乱序，但是stream里面的frame必须要个有序。客户端的stream是奇数号，服务端的stream是偶数号。streamID不能复用，达到上限后发送控制帧GOAWAY关闭tcp连接。stream上限是128个。
* 主动推送资源， 客户端请求html超文本，服务端主动推送.css渲染文件，减少消息传递次数。服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。

缺点：HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，所有的http请求都在等这个字节数据到达。这就是 HTTP/2 队头阻塞问题。

### http/3.0(使用udp)
QUIC协议：
* 无队头阻塞，多个stream之间没有依赖，都是独立的，没有底层协议限制，某个stream发生丢失只会影响该流不会影响其他流；
* 建立连接速度快，QUIC 内部包含 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果
* 连接迁移，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；

另外 HTTP/3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP/2 的 HPACK 队头阻塞问题。
* QPACK Encoder Stream，将不属于静态表的```key-value```传递给对方
* QPACK Decoder Stream，回应对方已经收到。

### WebSocket协议
websocket, 是借助http协议完成升级的一个应用层协议，用于客户端和服务端之间的大量数据传递，且能够运用TCP的全双工机制，http/1.1只有半双工。

建立WebSocket连接，在完成tcp三次握手之后使用一次http通信，在http头部加入以下字段
```
Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n`
```
等待服务器进行回应之后双方的随机数没有问题，就能建立websocket连接了。

websocket连接消息格式：<br>
opcode，表示什么类型的数据帧（1：text数据帧；2：二进制类型数据帧；8：关闭连接数据帧）
payload，表示真正想要传输的数据的长度，单位字节。在格式中有三种长度类型：长度为7位、长度为16位、长度位32位、长度位16位。当长度超过7bit时读取7 + 16位，长度超过7 + 16bit时，读取7 + 16 +32位。<br>
payload data，传输的真正的数据<br>

websocket采用的也是消息头 + 消息体的结构（http、rpc也是）采用这种结构时防止出现tcp粘包问题。因为tcp时全双工面向字节流的数据传输协议，如果上层协议不适用消息头 + 消息体包装数据会出现。

该协议应用于在websokcet网页游戏中，玩家收到的伤害以及其他npc产生的数据都是由服务器主动通过传输websocket报文在客户端中处理并显示。

### rpc协议
rpc协议诞生于上世纪80年代，是作为远程过程调用，就是调用远程服务器的一个方法就像调用本地服务器一样。

rpc在C/S架构下进行，http在B/S架构下进行。

rpc和http的区别
* 服务发现。http通过DNS服务器获得服务器的IP地址，rpc由专门的中间服务取保存服务名和ip信息。
* 底层连接。http/1.1采用的是长连接的方式，让后续的请求和响应复用这条连接。rpc也是通过长连接的方式与服务端进行连接，不同的是rpc还会创建一个连接池，请求量大的时候创建多条连接放在连接池内，复用连接池内的连接。
* 传输内用。两者都是采用消息头 + 消息体的报文格式。http采用josn序列化结构体数据，rpc采用Protobuf序列化结构体数据。



## TCP
1、tcp头格式：源端口号、目的端口号、序列号、确认序列号、首部长度、保留位、URG、ACK、PSH、RST、SYN、FIN、窗口大小、校验和、紧急指针、选项、数据

ack为1时，确认应答位有效，除了建立连接的时候的syn包外，其余包都位1<br>
RST为1，TCP连接出现异常，强制断开。<br>
SYN为1，表示希望建立连接，序列号初始化<br>
FIN为1, 表示主动断开连接今后不会再有数据发送。

2、什么是TCP？

TCP是面向连接的、可靠的、字节流的传输层通信协议；

面向连接：一定是一对一通信, 经过连接之后才能进行连接，不能一对多或者多对一。<br>
可靠的：无论网络中出现了怎样的链路变化，TCp都可以保证一个报文一定达到接收端。<br>
字节流：用户通过TCP进行传输的时候可能会被操作胸痛分成多个TCP报文，如果接收方的程序不知道消息的边界，是无法读出有效的用户消息。并且TCP报文是有序的，没有接收到完整的消息报文时不会交付应用层处理的。

3、什么时tcp连接？

tcp连接是用于保证可靠性和流量控制维护的某些状态信息，包括socket（IP地址和端口号组成）、序列号（解决tcp包乱序问题）、窗口大小（用于做流量控制）。

4、如果唯一确定一个tcp连接？

使用tcp四元组：源ip地址 + 源端口号 + 源目的地址 + 目的端口号；

服务端监听一个端口号最多接受的理论连接数：客户端ip数量 * 客户端端口数

在32位IP地址中：客户端IP数最多位2^32，端口数最多为2^16，所以单机最多能接受的tcp连接数为2^48个。但是会受到内存限制和文件描述符限制。

5、udp和tcp有什么区别？分别的应用场景？

* 首部。udp和tcp的报文首部有很大的区别，udp只有源端口和目的端口、包长度、校验和、数据，且udp的首部不会变长。相比之下tcp的首部内容比udp多，且tcp的首部可能会变长（使用“选项”字段），如果不使用“选项”字段的话就是20字节的开销。

* 连接方式：udp面向无连接传输数据。tcp面向连接，传输之前要先建立连接。
* 服务对象：udp支持一对一，一对多，多对多的交互通信。tcp指支持一对一的交互方式。
* 可靠性：udp是不可靠的传输协议，只负责发送数据包。tcp是可靠的传输协议，保证接收端能接受到数据包。
* 拥塞控制、流量控制。udp没有该机制，即使网络非常拥堵，也不会影响udp的发送速率。tcp有该机制，用于保证数据传输的安全性。
* 传输方式。udp是一个包一个包的发送，可能会乱序和丢包。tcp是流式传输，没有边界，但是保证顺序和可靠。
* 分片不同。tcp的数据如果大于MSS会在传输层进行分片，目标主机收到后，同样在传输层组装tcp数据包，若其中一个分片丢失，重传该分片。udp的数据大小如果大于MTU大小，则会在IP层进行分片，**目标主机收到后，在IP层组装完数据**，接着再传给传输层。

应用场景：tcp用于FTP文件传输，HTTP/HTTPS。udp用于包量较少的通信，视频、音频灯多媒体通信、广播通信。

6、tcp和udp能使用一个端口？
可以，内核中tcp和udp是完全独立的两个模块。接收到消息后根据ip包头的协议号判断是udp还是tcp内核将对应的模块，然后通过端口传输给对应的应用程序。

7、TCP三次握手是怎样的？
* 第一次握手：客户端主动发起连接请求，syn为1，初始化客户端序列号，客户端进入`SYN_SENT`状态。
* 第二次握手：服务端应答客户端的请求，ack = 1，序列号为服务端初始化的序列号，确认序列号为客户端初始化的序列后 + 1，服务端从 `listen` 进入`SYN_REVD`.
* 第三次握手：应答服务端，ack = 1，确认序列号为服务端的序列号+ 1, 客户端进入 `ESTABLISHED`。且第三次握手可以携带数据, 服务器在接收数据后也进入`ESTABLISHED`状态。

在linux中使用```netstat -napt```查看tcp的连接状态。

8、[重点]为什么要三次握手？
* 阻止重复历史连接初始化
* 同步双方初始序列号
* 避免浪费资源

9、为什么要四次挥手？
* 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
* 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

10、四次挥手的过程：
* 客户端主动发送FIN报文断开连接，进入`FIN_WAIT_1`状态，此时不能发送请求但是能接受响应。
* 服务端收到FIN报文，回应一个ack报文，进入`CLOSED_WAIT`状态，并处理完剩下的数据，此时不能接收请求，但是能发送消息。客户端接收到之后进入`FIN_WAIT2`状态。
* 服务器中的websever应用程序调用close()，内核向客户端发送FIN报文，服务器进入`LAST_ACK`状态。
* 客户端接收到FIN报文，回应ACK报文，进入`TIME_WAIT`状态，两个MSL内如果内什么其他异常就自动给关闭连接。而服务端收到客户端最后发送的ACK报文之后，关闭连接。

至此，标志着人类70年代伟大的计算机里程开始了新的篇章。

11、为什么TIME_WAIT的时间是2MSL？

因为数据在网络上传播一来一回的时间最多是2MSL，在第三次挥手的时候收到服务端的报文之后就开始time_wait等待，2个MSL之后客户端关闭，如果ack报文丢失服务端重传的FIN报文会在2个MSL时间之内到达。（ack报文不可重传）（重传的FIN报文丢失的概率时非常小的，第二次发送的ack报文丢失的概率也是非常小的）

12、已经建立连接、但是客户端突然故障了怎么办？

借助TCP的保活机制，通过保活机制判断当前的TCP是否存活；

* 如果对端主机宕机并重启，接收到tcp的保活探测报文之后，发现并没有该连接的有效信息，会产生一个RST报文
* 如果对端主机宕机没有重启，或者其他原因导致探测报文不可到达。连续几次还是这样的话，达到保活探测次数之后，tcp报告该tcp已经死亡。

tcp的保活机制有点长，可以在服务端实现一个定时器，定时器维护每个socket的连接状态超过规定时间没有消息传递就触发回调函数释放连接，减少服务器的压力，和我项目中的webserver定时器的机制一样。

13、socket编程

* 服务端和客户端都初始化socket，得到文件描述符；
* 服务端调用bind，将socket并定到指定的ip地址和端口；
* 服务端调用listen监听
* 服务端调用accept，等待客户端连接
* 客户端调用connect，向服务端的地址和端口发起连接请求
* 服务端accept返回用于传输的socket的文件描述符
* 客户端调用write写入数据，服务端调用read读取数据
* 客户端断开连接时调用close，服务端read读取数据的时候就会读取到EOF，处理完数据，服务端调用close，表示结束。

监听的socket和连接的socket时两个不同的socket。

### tcp重传
包括超时重传和快速重传、在快速重传基础上的SACK重传和D-SACK重传

**超时重传** 每个未确认的数据包都有一个定时器，当超过定时器中的时间还没有收到确认报文认为该数据包丢失，启动超时重传，并且当前重传的定时器时间设置时上一次的2倍。

**快速重传** 当连续收到同一个确认报文的时候发送端认为出现了丢包，然后重发数据包，但是快速重传不知道是哪有多少个数据包出现了丢包情况，没有sack机制的情况下快速重传只会重复发送第一个最后一个顺序收到的数据包序列号 + 1。如果后面还有数据包丢失的话就不知道要重传哪个了。

**SACK**机制下的重传，确认报文在tcp头部中的“选项”字段中发送当前已收到的数据信息发送给发送方。发送方接收方双方支持SACK机制才能使用快速重传方法。

**D-SACK**机制，用于告诉发送端数据包被接收的情况（丢包、接收端的ack丢包、延迟、发送方数据包被复制）

### 滑动窗口

发送窗口：发送窗口的大小受到接收窗口大小的限制，发送窗口中分为`已发送未确认`的数据、`能发送未发送的数据`、`不能发送但是未发送的数据`，通过滑动窗口来进行tcp的流量控制，防止发送方消息发送过快导致接收方处理不及时丢包影响网络效率。

接收窗口：接收窗口中包括`未收到数据但可以接收数据`。

接收窗口和发送窗口的大小不是一成不变的，接收窗口的大小根据通过流量控制进行维护，有以下几种情况：
* 服务器不繁忙，接收端接收信息之后立即读取，此时接收窗口不变
* 服务器比较繁忙，接收端接收信息之后来来不及读取或者只读取一部分，此时要通过tcp头部中的`windows`字段告诉发送端调整窗口大小。如果操作系统中的缓冲区已经满了，此时的接收端窗口大小为0，并通过ack报文提醒发送端，窗口大小为0停止发送，等过一段时间发送端发送窗口探测是否能进行数据传输（窗口探测达到3次之后还是不能传输的话发送RST异常关闭）
* 服务器资源非常繁忙，通过调整缓冲区缩小窗口大小，但是操作系统缩小服务器窗口大小之前一定要提前告知发送端，并延后缩小。否则会出现发送端在窗口的可发送数据区域发送数据 到达接收端后 超过接收端窗口大小造成丢包，而发送端的才收到缩小缓冲区的通知，此时造成丢包。

为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。


### 糊涂窗口

糊涂窗口是指，接收方在接收窗口满了之后腾出几个字节的空间，然后发送方立刻发送。造成了大开销传输小数据的情况。

解决糊涂窗口：
* 接收方不通告小窗口，即接收方的窗口 >= min(MSS / 2, 缓存空间) 才通知发送端，否则返回0size;
* 发送方使用Nagle算法避免发送小数据，即当满足以下任意一个条件才能发送数据：（1）等到窗口 >= MSS 或数据 >= MSS;(2)收到之前发送数据的ack包。

使用Nagle算法的前提是接收方不通告小窗口，否则发送方收到之前发送的数据ack包还是会继续发送小数据。

### 拥塞控制（慢启动、拥塞避免、拥塞发生、快速恢复）
没有在规定时间内收到ack报文，认为网络出现了拥塞。

为了避免阻塞网络，所以tcp采用慢启动的方式：收到一个ack，拥塞窗口(cwnd) + 1, 直到拥塞窗口增长到慢启动门限ssthresh，启用拥塞避免算法法。此时收到一个ack包增加（1 / cwnd）个窗口，即达到慢启动门限之后拥塞窗口进行线性增长。拥塞发生有两种做法（超时重传）和（快速重传）：`超时重传`慢启动门限变为原来的二分之一，拥塞窗口变为1，重启开始慢启动。`快速恢复`和快速重传同时使用，当发生快速重传的时候，拥塞窗口和慢启动门限的变化：```cwnd /= 2; ssthesh = cwnd```，然后进入快速恢复，将 cwnd += 3；如果继续收到重传的ack，则cwnd += 1 ；如果收到新的数据报ack说明快速恢复完成，恢复以前的状态，将cwnd = ssthesh；

### 快速建立连接
打开fastopen功能 设置net.ipv4.tcp_fastopen的值0/1/2/3, 功能分别是关闭/作为客户端开启/作为服务端开启/同时作为客户端和服务端开启

在第二次握手的时候服务端携带一个cookies文件一同发送。在第三次握手的时候客户端携带GET请求，在下一次Get请求就可以通过cookies进行快速连接，第二次请求的时候将请求建立的时延从2.5RTT下降到1RTT

### 延迟确认
为了提高效率ack报文一般会携带响应数据，如果当前有响应数据，则随着ack一起立刻发送给对方，没有响应数据的时候则延迟一段时间（等待时间过了直接发送ack）发送，等有响应数据的时候携带响应数据一起发送。如果在延迟发送ack期间下一个数据报文又到了，则立刻发送ack报文

### 延迟确认和NEGLE算法同时使用会增加时耗
因为NEGLE算法要收到下一个ack才能发送数据所以一直会在发送短堆积数据，延迟发送要等超过延迟发送时间才能进行发送。
所以等待时间非常久。

### tcp全连接队列与tcp半连接队列
#### 全连接队列
tcp全连接队列可以通过 `ss` 命令查看，输出有两种情况一种是正在监听、一种是不在listen的：
* 在listen状态下：`Recv-Q`表示当前全连接队列的大小，也就是完成三次握手等待被accept()的tcp连接；`Send-Q`表示当前全连接队列的最大长度。
* 在非listen状态下：`Recv-Q`表示已收到但是未被应用接收的字节数；`Send-Q`表示已发送但是未收到恢复的字节数。

超过tcp的最大连接数，服务端会丢弃后续到来的tcp连接。因此当服务端的全连接队列过小的时候容易溢出，tcp全连接队列溢出的时候会丢弃后续进来的tcp连接。

全连接队列溢出后linux默认操作时丢弃后续进来的tcp队列，但是也可以让linux向客户端发送给RST报文断开连接。通过设置`tcp_abort_on_overflow`，为0时候全队列发生溢出server扔掉后续进来的client；为1的时候向客户端发送RST报文告诉客户端。

但是实际上不会设置恢复RST报文断开客户端的连接，而是让客户端不断地重连，这样能让客户端在服务端不繁忙地时候连接上服务端。当遇到客户端流量增加的时候可以通过增大全连接队列的长度缓解

可以通过调整somaxconn和backlog的值进行改变全队列最大的值，全连接队列最大长度 = min(somaxconn, baklog)；通过`/proc/sys/net/core/somaxconn`设置`somaxconn`的值，通过配置文件修改`backlog`的值。

当不断地有tcp连接因为tcp全连接队列溢出而被丢弃，应当增大全连接队列的最大值。

当全连接队列满的时候除了丢弃连接还能通过调整`tcp_abort_on_overflow`参数为1，目的是：当全连接队列满的时候发送RST报文给客户端关闭连接

#### 半连接队列
通过`netstat -natp | grep STN_RECV | wc -l`计算tcp半连接的队列。

tcp半连接丢弃连接的条件：
* 半连接队列满，且服务端没有开启cookies
* 全连接队列满，且没有重传 `SYN + ACK` 包的数量多于一个。
* 如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog >> 2)，则会丢弃；

防御SYN攻击：
* 增大半连接队列：增大半连接队列不仅仅是增大`tcp_max_syn_backlog`，还需要增大全连接队列的值，不然会收到全连接队列的限制导致半连接队列丢弃连接。
* 开启cookies功能，开启cookies功能，完成过三次握手之后就会获得一个cookies，通过cookies直接进入全连接队列不需要经过半连接队列的等待。
* 减少`SYN + ACK`重传次数，当收到大量的SYN请求之后，会不断的重传 `SYN + ACK` 包只要减少重传次数就能加快出于SYN_REVC状态得TCP连接断开。

半连接队列满了只能丢弃连接吗？
除了丢弃连接还可以开启cookies功能，开启cookies功能就可以在不使用SYN半连接队列的情况下进行tcp连接

### SYN_RCV状态的优化
服务端发送SYN + ACK报文之后进入`SYN_RCVD`状态，客户端收到`SYN + ACK`报文之后，客户端发送ACK报文并进入`ESTABLISHED`状态，服务端收到后再进入`ESTABLISHED`状态。

如果服务端一直没收到ACK报文的话，那么一直会处于`SYN_RCVD`状态，重发SYN + ACK报文，linux系统中最大重发次数受到tcp_synack_retries参数的限制。当网络堵塞的时候可以通过`/proc/sys/net/ipv4/tcp_synack_retries`增大重传次数。